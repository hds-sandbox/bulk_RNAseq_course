---
title: "Hypothesis testing with DESeq2"
author: "Jose Alejandro Romero Herrera"
date: '`r Sys.Date()`'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding,
                        output_format='all',
                        output_dir='./')})
output:
  # To create PDF report, uncomment below
  #pdf_document:
  #  toc: yes  
  html_document:
    theme: yeti # nice theme for the webpage
    toc: yes # table of contents
    toc_float: yes # table of contents "floats" in the document
    df_print: paged # data frames are interactive
    dev: png # what format do you want for the figures?
---

```{r knitr, include = FALSE}
DOCNAME = knitr::current_input()
DOCNAME = gsub(DOCNAME, pattern = ".Rmd", replacement = "", fixed = T)
knitr::opts_chunk$set(autodep        = TRUE,
                      cache          = FALSE,
                      echo           = TRUE,
                      error          = FALSE,
                      fig.align      = "center",
                      fig.path       = paste0("./img/", DOCNAME, "/"), #images will be put in this folder, under the notebook name
                      message        = FALSE,
                      warning        = FALSE,
                      eval           = TRUE)
```

```{r setup, include = FALSE, echo = FALSE}
# DO NOT RUN IF YOU HAVE ALREADY RUN PREVIOUS NOTEBOOKS
# This chunk is ONLY necessary if you want to knit this document into a pdf!!
library(tidyverse)
library(DESeq2)
library(tximport)

setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
meta <- read_csv("/work/Intro_to_bulkRNAseq/Data/samplesheet.csv")
dir <- "/work/Intro_to_bulkRNAseq/Data/salmon"
tx2gene <- read_table("/work/Intro_to_bulkRNAseq/Data/salmon_tx2gene.tsv", col_names = c("transcript_ID","gene_ID","gene_symbol"))
files <- file.path(dir, meta$sample, "quant.sf")
names(files) <- meta$sample
txi <- tximport(files, type="salmon", tx2gene=tx2gene, countsFromAbundance = "lengthScaledTPM", ignoreTxVersion	= TRUE)
dds <- DESeqDataSetFromTximport(txi,
                                   colData = meta %>% column_to_rownames("sample"), 
                              design = ~ condition)
keep <- rowSums(counts(dds)) > 0
dds <- dds[keep,]
dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds)
```

Approximate time: 90 minutes

## Learning Objectives

-   Discuss the steps required to generate a results table for pairwise comparisons (Wald test)
-   Recognize the importance of multiple test correction
-   Identify different methods for multiple test correction
-   Summarize the different levels of gene filtering
-   Evaluate the number of differentially expressed genes produced for each comparison
-   Construct R objects containing significant genes from each comparison

## DESeq2: Model fitting and Hypothesis testing

The final step in the DESeq2 workflow is taking the counts for each gene and fitting it to the model and testing for differential expression.

### Generalized Linear Model

As described [earlier](06a_count_matrix.md), the count data generated by RNA-seq exhibits overdispersion (variance \> mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a **negative binomial distribution to model the RNA-seq counts using the equation below**:

```{r, echo = FALSE, eval = TRUE}
knitr::include_graphics("./img/07b_hypothesis_testing/NB_model_formula.png")
```

The two parameters required are the **size factor, and the dispersion estimate**. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.

After the model is fit, coefficients are estimated for each sample group along with their standard error. The coefficients are the estimates for the **log2 fold changes**, and will be used as input for hypothesis testing.

### Hypothesis testing

The first step in hypothesis testing is to set up a **null hypothesis** for each gene. In our case, the null hypothesis is that there is **no differential expression across the two sample groups (LFC == 0)**. Second, we use a statistical test to determine if based on the observed data, the null hypothesis can be rejected. In DESeq2, the **Wald test is the default used for hypothesis testing when comparing two groups**.

The GLM and the statistical testing is done using the function `nbinomWaldTest()`

```{r}
dds <- nbinomWaldTest(dds)
```

The **model fit and Wald test were already run previously as part of the `DESeq()` function**:

```{r, eval = FALSE}
## DO NOT RUN THIS CODE

## Create DESeq2Dataset object
dds <- DESeqDataSetFromTximport(txi,
                                   colData = meta %>% column_to_rownames("sample"), 
                              design = ~ condition)
## Run analysis
dds <- DESeq(dds)
```

## Exploring Results

By default DESeq2 uses the Wald test to identify genes that are differentially expressed between two sample groups. Given the factor(s) used in the design formula, and how many factor levels are present, we can extract results for a number of different comparisons.

### Specifying contrasts

In our dataset, we have three sample groups so we can make three possible pairwise comparisons:

1.  Control vs. Mov10 overexpression
2.  Control vs. Mov10 knockdown
3.  Mov10 knockdown vs. Mov10 overexpression

**We are really only interested in #1 and #2 from above**. When we initially created our `dds` object we had provided `~ sampletype` as our design formula, indicating that `sampletype` is our main factor of interest.

To indicate which two sample groups we are interested in comparing, we need to specify **contrasts**. The contrasts are used as input to the DESeq2 `results()` function to extract the desired results.

Contrasts can be specified in three different ways (with the first method more commonly used):

1.  Contrasts can be supplied as a **character vector with exactly three elements**:

```{r, eval = FALSE}
# DO NOT RUN!
contrast <- c("condition", "level_to_compare", "base_level")
results(dds, contrast = contrast)
```

2.  Contrasts can be given as a **list of 2 character vectors**: the names of the fold changes for the level of interest, and the names of the fold changes for the base level. These names should match identically to the elements of `resultsNames(object)`. *This method can be useful for combining interaction terms and main effects.*

```{r, eval = FALSE}
# DO NOT RUN!
resultsNames(dds) # to see what names to use
contrast <- list(resultsNames(dds)[1], resultsNames(dds)[2])
results(dds, contrast = contrast)
```

3. One of the results from `resultsNames(dds)` and the `name` argument. This one is the simplest but it can also be very restricted:

```{r, eval = FALSE}
# DO NOT RUN!
resultsNames(dds) # to see what names to use
results(dds, name = resultsNames(dds)[2])
```

Alternatively, if you **only had two factor levels you could do nothing**:

```{r}
results(dds)
```

To start, we want to evaluate **expression changes between the MOV10 overexpression samples and the control samples**. As such we will use the first method for specifying contrasts and create a character vector:

***

**Exercise 1**

Define contrasts for MOV10 overexpression using one of the two methods above.

```{r}
## Your code here 
contrast_oe <- 
```

***

## The results table

Now that we have our contrast created, we can use it as input to the `results()` function.

```{r}
?results
```

You will see we have the option to provide a wide array of arguments and tweak things from the defaults as needed. For example:

```{r}
## Extract results for MOV10 overexpression vs control with a pvalue < 0.05
res_tableOE <- results(dds, contrast=contrast_oe, alpha = 0.05)
```

The results table that is returned to us is **a `DESeqResults` object**, which is a simple subclass of DataFrame.

```{r}
# Check what type of object is returned
class(res_tableOE)
```

Now let's take a look at **what information is stored** in the results:

```{r}
# What is stored in results?
res_tableOE %>% 
  data.frame() %>% 
  head()
```

We can use the `mcols()` function to extract information on what the values stored in each column represent:

```{r}
# Get information on each column in results
data.frame(mcols(res_tableOE, use.names=T))
```

-   `baseMean`: mean of normalized counts for all samples in your count matrix
-   `log2FoldChange`: log2 fold change
-   `lfcSE`: standard error for the lfc calculation
-   `stat`: Wald statistic
-   `pvalue`: Wald test p-value
-   `padj`: BH adjusted p-values

### Gene-level filtering

Let's take a closer look at our results table. As we scroll through it, you will notice that for **selected genes there are NA values in the `pvalue` and `padj` columns**. What does this mean?

```{r, echo = FALSE, eval = TRUE}
knitr::include_graphics("./img/07b_hypothesis_testing/gene_filtering.png")
```

The missing values represent genes that have undergone filtering as part of the `DESeq()` function. Prior to differential expression analysis it is **beneficial to omit genes that have little or no chance of being detected as differentially expressed.** This will increase the power to detect differentially expressed genes. DESeq2 **does not physically remove** any genes from the original counts matrix, and so all genes will be present in your results table. The genes omitted by DESeq2 meet one of the **three filtering criteria outlined below**:

**1. Genes with zero counts in all samples**

If within a row, all samples have zero counts there is no expression information and therefore these genes are not tested. Since we have already filtered out these genes ourselves when we created our `dds` object.

```{r}
# Show genes with zero expression
res_tableOE %>%
  as_tibble(rownames = "gene") %>% 
  dplyr::filter(baseMean==0) %>%
  head()
```

> **If there would be any genes meeting this criteria, the baseMean column for these genes will be zero, and the log2 fold change estimates, p-value and adjusted p-value will all be set to NA.**

**2. Genes with an extreme count outlier**

The `DESeq()` function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook's distance. If several samples are flagged for a certain gene, the gene is filtered out.

```{r}
# Show genes that have an extreme outlier
res_tableOE %>% 
  as_tibble(rownames = "gene") %>% 
  dplyr::filter(is.na(pvalue) & is.na(padj) & baseMean > 0) %>%
  head()
```

It seems that we have some genes with outliers!

> **If a gene contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA.**

**3. Genes with a low mean normalized counts**

DESeq2 defines a low mean threshold, that is empirically determined from your data, in which the fraction of significant genes can be increased by reducing the number of genes that are considered for multiple testing. This is based on the notion that genes with very low counts are not likely to see significant differences typically due to high dispersion.

```{r}
# Show genes below the low mean threshold
res_tableOE %>% 
  as_tibble(rownames = "gene") %>% 
  dplyr::filter(!is.na(pvalue) & is.na(padj) & baseMean > 0) %>%
  head()
```

> **If a gene is filtered by independent filtering, then only the adjusted p-value will be set to NA.**

> ***NOTE:** DESeq2 will perform the filtering outlined above by default; however other DE tools, such as EdgeR will not. Filtering is a necessary step, even if you are using limma-voom and/or edgeR's quasi-likelihood methods. Be sure to follow pre-filtering steps when using other tools, as outlined in their user guides found on Bioconductor as they generally perform much better.*

## Fold changes

With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also **add a fold change threshold**. Keep in mind when setting that value that we are working with log2 fold changes, so a cutoff of `log2FoldChange` \< 1 would translate to an actual fold change of 2.

> ### An alternative approach to add the fold change threshold:
>
> The `results()` function has an option to add a fold change threshold using the `lfcThreshold` argument. This method is more statistically motivated, and is recommended when you want a more confident set of genes based on a certain fold-change. It actually performs a statistical test against the desired threshold, by performing a two-tailed test for log2 fold changes greater than the absolute value specified. The user can change the alternative hypothesis using `altHypothesis` and perform two one-tailed tests as well. **This is a more conservative approach, so expect to retrieve a much smaller set of genes!**

```{r, eval = FALSE}
res_tableOE_LFC1 <- results(dds, contrast=contrast_oe, alpha = 0.05, lfcThreshold = 1)
```

## Summarizing results

To summarize the results table, a handy function in DESeq2 is `summary()`.

```{r}
## Summarize results
summary(res_tableOE, alpha = 0.05)
```

In addition to the number of genes up- and down-regulated at the default threshold, **the function also reports the number of genes that were tested (genes with non-zero total read count), and the number of genes not included in multiple test correction due to a low mean count**.

## Extracting significant differentially expressed genes

Let's first create variables that contain our threshold criteria. We will only be using the adjusted p-values in our criteria:

```{r}
### Set thresholds
padj.cutoff <- 0.05
```

We can easily subset the results table to only include those that are significant using the `dplyr::filter()` function, but first we will convert the results table into a tibble:

```{r}
# Create a tibble of results and add gene symbols to new object
res_tableOE_tb <- res_tableOE %>%
  as_tibble(rownames = "gene") %>%
  relocate(gene, .before = baseMean)

head(res_tableOE_tb)
```

Now we can subset that table to only keep the significant genes using our pre-defined thresholds:

```{r}
# Subset the tibble to keep only significant genes
sigOE <- res_tableOE_tb %>%
  dplyr::filter(padj < padj.cutoff)
```

```{r}
# Take a quick look at this tibble
head(sigOE)
```

Now that we have extracted the significant results, we are ready for visualization!

***

**Exercise 2**

**MOV10 Differential Expression Analysis: Control versus Knockdown**

Now that we have results for the overexpression results, do the same for the **Control vs. Knockdown samples**.

1.  Create a contrast vector called `contrast_kd`.
2.  Use contrast vector in the `results()` to extract a results table and store that to a variable called `res_tableKD`.
3.  Using a p-adjusted threshold of 0.05 (`padj.cutoff < 0.05`), subset `res_tableKD` to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.
4.  How many genes are differentially expressed in the Knockdown compared to Control? How does this compare to the overexpression significant gene list (in terms of numbers)?
